

# HTTP 일반 헤더

[TOC]

## HTTP 헤더 개요

### 용도

- HTTP 전송에 필요한 모든 부가 정보가 들어감
  - 메시지 Body 내용, 메시지 Body 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 등
- 표준 헤더가 매우 많음
- 필요시 임의의 헤더 추가 가능

### HTTP Body

**message body - RFC7230(최신)**

![스크린샷 2021-01-13 오후 11.01.47](https://media.vlpt.us/images/dnstlr2933/post/bed630c4-b16d-42a0-a25d-880c48108161/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-13%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.01.47.png)

- 메시지 본문을 통해 **표현 데이터** 전달

- 메시지 본문 == 페이로드 (payload).

  -  데이터를 실어나를 데이터 부분을 페이로드라고 함

- **표현은 요청이나 응답에서 전달할 실제 데이터**

  - 표현 = 표현 데이터 + 표현 헤더

- **표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공**

  

### 표현 헤더

- Content-Type : 표현 데이터의 형식

  - 메시지 바디에 들어가는 데이터가 무엇인지 설명

  - 미디어 타입, 문자 인코딩 등

  - 예시)

    - text/html;charset=UTF-8

    - application/json
    - image/jpg

- Content-Encoding : 표현 데이터의 압축 방식

  - 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가해줌
  - 데이터를 받은 곳에서 인코딩 헤더의 정보로 압축 해제
  - 예시)
    - gzip (압축)
    - deflate
    - identity (압축하지 않음)

- Content-Language : 표현 데이터의 자연 언어

  - 이 표현 데이터가 한국어인지, 영어인지
  - 예시
    - ko, en, en-US 등

- Content-Lenght : 표현 데이터의 길이

  - 정확하게는 표현데이터의 길이가 아닌, 페이로드의 길이
  - 바이트 단위 길이
  - Transfer-Encoding (전송코딩)을 사용하면, Content-Length를 사용해선 X
    - Transfer-Encoding는 길이에 대한 정보를 이미 포함함.

- 표현 헤더는 전송, 응답 둘 다 사용됨







## 콘텐츠 협상

**클라이언트가 선호하는 표현을 서버에 요청** 

협상 헤더는 **요청시**에만 사용

### 협상 헤더

- Accept : 선호하는 미디어 타입 요청
- Accept-Charset : 선호하는 문자 인코딩 요청
- Accept-Encoding : 선호하는 압축 인코딩 요청
- Accept-Language : 선호하는 자연언어 요청


**예시**

- Accept-Language 적용 전

  ![**Accpt-Language 적용 전**](https://media.vlpt.us/images/dnstlr2933/post/d23c6749-79c5-410a-861a-50267bc19f91/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-13%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.30.21.png)

- Accept-Language 적용 후

  ![**Accpt-Language 적용 후**](https://media.vlpt.us/images/dnstlr2933/post/04274ac2-bb78-445c-9f5c-f68737914883/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-13%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.31.19.png)

### 협상과 우선순위

- **Quality Value(q) 값을 사용하여, 우선순위 설정**

  - q는 0~1의 값을 가지며, 값이 클수록 높은 우선 순위를 가짐
  - q 값이 생략된 경우 1을 의미
  - 예시 
    - Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
      - 1순위 : ko-KR;q=1
      - 2순위 : ko;q=0.9
      - 3순위 : en-US;q=0.8
      - 4순위 : en;q=0.7

- **구체적인 것을 우선시**

  - 선호하는 값이 구체적일 수록, 높은 우선순위를 가짐

  - 예시
    - Accept: text/*, text/plain, text/pain;format=flowed, \*/\*
      - 1순위 : text/pain;format=flowed
      - 2순위 : text/plain
      - 3순위 : text/*
      - 4순위 : \*/\*

- 사용 가능한 미디어 타입을 구체적인 것을 기준으로 매핑하여, 우선순위(q 값) 부여

  - 예시

    - Accept: `text/*;q=0.3`, `text/html;q=0.7`, `text/html;level=1`, `text/html;level=2;q=0.4`, `*/*;q=0.5`

      | 사용가능한 Media Type | Quality value                                                |
      | --------------------- | ------------------------------------------------------------ |
      | text/html;level=1     | 1 (생략한 경우 q 값은 1)                                     |
      | text/html             | 0.7 (text/html에도 해당되지만, 더 구체적인 기준으로 매핑되기에 0.7 부여 |
      | text/plain            | 0.3                                                          |
      | image/jpg             | 0.5                                                          |
      | text/html;level=2     | 0.4 (text/html에도 해당되지만, 더 구체적인 기준으로 매핑되기에 0.4 부여) |
      | text/html;level=3     | 0.7 (text/html에도 해당)                                     |

      

## 전송 방식

- 단순 전송 (**Content-Length**)

  - 전달하고자 하는 message-body의 바이트 길이를 아는 경우, 그에 맞는 `Content-Length` 를 전달
  - 예시 : Content-l=Length : 3412

- 압축 전송 (**Content-Encoding**)

  - 전달하고자 하는 표현 데이터를 압축하되, 표현 헤더에 `Content-Encoding`을 통해 압축 방식 타입을 전달
  - 예시 : Content-Encdoing : gzip

- 분할 전송 (**Transfer-Encoding**)

  ![분할 전송](https://media.vlpt.us/images/dnstlr2933/post/ff1dae48-b7c8-4e4b-a887-2a573dfe80fc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.19.56.png)

  - 용량이 큰 데이터의 경우, 한 번에 전송(단순 전송)하면 걸리는 시간이 크므로 분할해서 조금씩 데이터를 볼 수 있도록 전송 (스트리밍에 해당되지 않을까..)
  - 각 데이터의 바이트의 길이를 같이 보냄
  - 데이터 전송이 끝난 경우, `\r\n` 을 보내고 바이트 길이는 0을 전송
  - `Transfer-Encoding: chunked`로 설정

- 범위 전송 (**Range, Content-Ranges**)

  ![범위 전송](https://media.vlpt.us/images/dnstlr2933/post/98c07a9b-f14d-4882-9a8a-72381e7aedf7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.24.37.png)

  - 데이터를 전달하다가 끊길 경우, 끊긴 데이터만 범위로 지정해서 주고 받음
  - 위 예시는 2000 데이터 중, 데이터 반을 전송받다가 끊긴 경우를 의미함

  

## 일반 정보

### From

**유저 에이전트의 이메일 정보**

- 검색 엔진 같은 곳에서 나의 사이트를 크롤링 하는 등 접근하는 경우, 해당 검색 엔진 담당자에게 이메일로 요청하는 경우 등에 사용됨
- 거의 사용되지 않음
- 요청에서 사용하는 정보

### Referer

**이전 웹 페이지 주소**

- 이를 통해 유입 경로 분석 가능
- Referer는 단어 referrer의 오타
- 요청에서 사용하는 정보

### User-Agent

**유저 에이전트 애플리케이션 정보**

- = 클라이언트 애플리케이션 정보
  - 예시 : Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36
- 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
- 통계 정보로 활용 가능
- 요청에서 사용하는 정보

### Server

**요청을 처리하는 ORIGIN 서버의 소프트웨어 정보**

- 예시 : 
  - Server : Apache/2.2.22 (Debian) 
  - Server : nginx

- 최종적으로 응답을 처리하는 서버 정보를 의미
- 응답에서 사용하는 정보

### Date

**메시지가 발생한 날짜와 시간**

- 응답에서 사용하는 정보

## 특별한 정보

### Host

**요청한 호스트 정보 (도메인)** → 필수 값

- 하나의 서버가 여러 도메인을 처리할 때 사용됨 (즉 하나의 IP 주소에 여러 도메인이 적용된 경우)
  - 가상 호스트를 통해서 하나의 IP 주소를 갖는 서버가 여러 개의 애플리케이션 구동 가능
  - 하지만 요청하는 클라이언트가 요청하는 호스트 도메인을 알려주지 않는다면, **서버는 그 중 어떤 서비스를 요청하는 지 알 수 없기에 호스트 정보 필요**

- 호스트 정보 X

![호스트 정보 X](https://media.vlpt.us/images/dnstlr2933/post/7fbbf6ff-4052-4036-82d8-465dcdf4daf0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.24.59.png)

- 호스트 정보 O

![호스트 정보 O](https://media.vlpt.us/images/dnstlr2933/post/2b4c2c43-aefe-455c-b924-e1b263b7813a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.26.15.png)

### Location

**페이지 리다이렉션**

- 웹 브라우저는 3XX 응답 결과에 Location 헤더가 있으면, **Location 위치로 자동 이동**
- 201 (Crated) 응답의 Location 값은 **요청에 의해 생성된 리소스 URI**
- 3XX (Redirection) 응답의 Location 값은 **요청을 자동으로 리다이렉션하기 위한 대상 리소스를 가리킴**

### Allow

**허용 가능한 HTTP 메서드**

- 405 (Method Not Allowed) 응답에서 포함해야 함
  - 즉, 서버가 허용하지 않은 Method 등이 온 경우 응답으로 405를 주면서, 허용하는 메서드를 알려주어야 함
- 예시
  - Allow : GET, HEAD, PUT → 즉, POST Method는 X

### Retry-After

**유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간**

- 503 (Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있음
- 날짜(Fri, 31 DEC 1999 23:59:59 GMT)를 표기하거나, 초 단위(120) 표기 가능

## 인증

### Authorization

**클라이언트 인증 정보를 서버에 전달**

- 인증하는 매커니즘마다 들어가는 값이 다름



### WWW-Authenticate

**리소스 접근시 필요한 인증 방법 정의**

- 리소스 접근시 필요한 인증 방법 정의
- 401 Unauthorized 응답과 함께 사용
- 예시
- WWW-Authenticate: `Newauth realm="apps", type=1, title="Login to\"apps\"", Basic realm="simple"`

## 쿠키

Set-Cookie : 서버에서 클라이언트로 쿠키 전달

Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

- HTTP의 Stateless 
  - 클라이언트와 서버가 요청과 응답을 주고  받고나면 연결이 끊어짐
  - 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못함
  - 클라이언트와 서버는 서로 상태 유지 X

Q : 그러면 어떻게 정보를 기억해야 할까...

A1 : 요청할때마다 정보를 서버에 같이 넘기자

 - 모든 요청에 사용자 정보가 포함되도록 함
   	- 보안 문제가 있고, 매 요청마다 사용자 정보를 포함하는 것이 번거롭
	- 브라우저를 완전히 종료하고 다시 열면 정보가 없음

A2 : 쿠키를 사용하자



### 쿠키예시

**로그인**

![로그인 예시](https://media.vlpt.us/images/dnstlr2933/post/af1c37b8-9378-4bd7-86c2-e77ca2b5132e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.57.51.png)

1. 클라이언트가 서버에 로그인 진행
2. 서버가 요청을 받고 응답으로 `Set-Cookie: user=홍길동` 을 포함해서 전달.
3. 웹 브라우저 내부에 있는 쿠키 저장소에 `user=홍길동`을 저장해 둔다.


 **로그인 이후 페이지 재접속**

![로그인 이후 페이지 재접속](https://media.vlpt.us/images/dnstlr2933/post/61d639aa-2e45-4229-a718-d6d2a50a550c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.23.47.png)

1. 로그인 이후에 웹 브라우저가 welcome 페이지에 접속

   - 자동으로 웹 브라우저는 해당 서버에 요청을 보낼때마다 쿠키 저장소를 탐색해서 `Coocke: user=홍길동` 을 헤더에 포함해서 서버에 보냄

     - 사실 보안을 위해 진짜 이름을 보내는 것이 아니라 `홍길동`에 해당하는 key 값을 서버에 보냄

   - 쿠키에 정보가 없다면 `홍길동` 이라는 정보가 없어 `손님` 과 같은 호칭을 응답으로 보내겠지만, 쿠키를 통해 `user` 의 이름을 응답으로 보냄

     - 사실 보안을 위해, 클라이언트에서 받은 key 값을 서버가 확인하여 `홍길동` 임을 인지

     

2. 서버가 받은 요청 메시지에 있는 `Coocke: user=홍길동` 을 확인하고, 응답 메시지로 `홍길동` 정보를 포함해서 줌



**쿠키를 이용한 요청 포맷**

웹 브라우저의 모든 요청은 쿠키 저장소에 있는 쿠키 정보를 자동으로 포함해서 보내짐

![스크린샷 2021-01-14 오후 3.27.04](https://media.vlpt.us/images/dnstlr2933/post/0bd89304-8d57-46d4-bf34-48b8e43c05a4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.27.04.png)



### 쿠키 특징

- 사용처
  - 사용자 로그인 세션 관리
  - 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송됨
  - 네트워크 트래픽이 추가적으로 유발됨
  - 그리하여, 최소한의 정보만 사용해야 함 (예시: 세션 id, 인증 토큰)
  - 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 사용
    - 웹스토리지 : 쿠키처럼 사용하고 싶기는 하지만, 요청할때 마다 보내는 것이 아니라 클라이언트에서 그냥 보관만 하고 있기를 바라고 필요할 때만 꺼내서 주기를 바라는 경우 사용됨



### 쿠키정보

- 생명주기 (**Expires, max-age**)
  - Set-Cookie: expires=Sat, 26-Dec-2020 04:50:59 GMT
    - 만료일이 되면 쿠키 삭제
  - Set-Cookie: max-age=3600 (초단위)
    - 0이하의 수를 지정하게되면 쿠키 삭제
    - 시간이 지나도 쿠키 삭제
  - 세션 쿠키 : 만료날짜를 생략하면 브라우저 종료시까지만 유지
  - 영속 쿠키 : 만료날짜를 입력하면 해당 날짜까지 유지
- 도메인 (**Domain**)
  - 명시 : 명시한 문서 기준 도메인 + 서브 도메인에서 쿠키 접근
    - domain=example.org를 지정하여 쿠키 생성
      - example.org는 물론이고, dev.example.org도 쿠키 접근 가능
  - 생략 : 현재 문서 기준 도메인만 쿠키 접근 가능
    - example.org에서 쿠키를 생성하고 domain 지정 생략
      - example.org에서 쿠키 접근 가능
      - dev.example.org에서 쿠키 접근 불가능

- 경로 (**path=/home**)
  - 입력한 경로를 포함한 하위 경로 페이지만 쿠키 접근 가능
  - 일반적으로 `path = (루트)` 로 지정
  - 예시 :  path=/home 지정
    - /home → O
    - /home/level1 → O
    - /hello → X

- 쿠키 보안 (**Secure, HttpOnly, SameSite**)

  기본적으로 쿠키는 http, https를 구분하지 않고 전송

  - Secure
    - `Secure` 설정시, https인 경우에만 쿠키 전송한다
  - HttpOnly
    - XSS 공격 방지
    - 자바스크립트에서 접근 불가능 (document.cookie) 
    - HTTP 전송에만 사용함
  - SameSite
    - XSRF 공격 방지
    - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송