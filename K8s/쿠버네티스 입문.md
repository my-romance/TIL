# 쿠버네티스 입문

쿠버네티스의 개념 및 기본 사용 방법을 정리하여 기록하고자 함.

또한 매니지드 서비스인 구글 쿠버네티스 엔진(GKE)에 대한 내용도 정리하여 요약하고자 함.

[TOC]



## 쿠버네티스란 무엇인가

쿠버네티스는 컨테이너 운영을 자동화하기 위한 컨테이너 오케스트레이션 도구.

컨테이너를 이용한 **애플리케이션 배포** 외에도 도커 호스트, 서버 리소스의 여유를 고려한 컨테이너 배치, 스케일링, 여러개의 컨테이너 그룹에 대한 로드 밸런싱, 헬스 체크 등의 기능을 갖춤

### 쿠버네티스 역활

쿠버네티스는 컴포즈/스택/스웜(여러 도커호스트를 클러스터로 묶어주는 컨테이너 오케스트레이션 도구 )의 기능을 통합해 더 높은 수준의 관리 기능을 제공하는 도구



## 쿠버네티스 실행

**kubectl 실행**

kubectl은 쿠버네티스를 다루기 위한 command line tool

**대시 보드 설치**

아래 명령어를 통해 대시보드 UI 배포

```
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml
```

다음 명령어를 실행해 STATUS=running 상태이면 배포가 잘 된 것

````
kubectl get pod --namespace=kube-system -1 k8s-app=kubernetes-dashboard
````

웹 브라우저로 대시보드 열기

```
kubectl proxy
```



## 쿠버네티스 주요 개념

### 쿠버네티스 리소스

| 리소스               | 용도                                                         |
| -------------------- | ------------------------------------------------------------ |
| 노드                 | 컨테이너가 배치되는 서버                                     |
| 네임스페이스         | 쿠베네티스 클러스터 안의 가상 클러스터                       |
| 파드                 | 컨테이너의 집합 중 가장 작은 단위로, 컨테이너의 실행방법을 정의 |
| 레플리카세트         | 같은 스펙을 갖는 파드를 여러개 생성하고 관리하는 역활을 함   |
| 디플로이먼트         | 레플리카 세트의 리비전을 관리                                |
| 서비스               | 파드의 집합에 점근하기 위한 경로를 정의                      |
| 인그레스             | 서비스를 쿠버네티스 클러스터 외부로 노출시킴                 |
| 컨피그맵             | 설정 정보를 정의하고 파드에 전달                             |
| 퍼시스턴트 볼륨      | 파드가 사용할 스토리지의 크기 및 종류 정의                   |
| 퍼시스턴트볼륨클레임 | 퍼시스턴트 볼륨을 동적으로 확보                              |
| 스토리지클래스       | 퍼시스턴트 불륨이 확보하는 스토리지의 종류를 정의            |
| 잡                   | 상주 실행을 목적으로 하지 않는 파드를 여러개 생성하고 정상적인 종료를 보장 |
| 크론잡               | 크론 문법으로 스케줄링되는 잡                                |
| 시크릿               | 인증 정보 같은 기밀 데이터를 정의                            |
| 롤                   | 네임스페이스 안에서 조작 가능한 쿠버네티스 리소스의 규칙을 정의 |
| 롤바인딩             | 쿠버네티스 리소스 사용자와 롤을 연결 짓는다                  |
| 클러스터롤           | 클러스터 전체적으로 조작 가능한 쿠버네티스 리소스의 규칙을 정의 |
| 클러스터롤바인딩     | 쿠버네티스 리소스 사용자와 클러스터롤을 연결 짓는다          |
| 서비스 계정          | 파드가 쿠버네티스 리소스를 조작할 때 사용하는 계정           |



## 쿠버네티스 클러스터와 노드

쿠버네티스 클러스터는 쿠버네티스의 여러 리소스를 관리하기 위한 집합체.

노드는 쿠버네티스 리소스 중에서 가장 큰 개념이며, **쿠버네티스 클러스터의 관리 대상으로 등록된 도커 호스트(컨테이너 호스트)**로 컨테이너가 배치되는 대상.

또한 쿠버네티스 클러스터 전체를 관리하는 서버인 마스터 노드가 적어도 하나 이상 필요

![클러스터](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)



**마스터를 구성하는 관리 컴포넌트**

쿠버네티스의 마스터 서버에 배포되는 관리 컴포넌트에는 다음과 같은 것이 있다

| 컴포넌트명              | 역활                                                         |
| ----------------------- | ------------------------------------------------------------ |
| kube-apiserver          | 쿠버네티스 API를 노출하는 컴포넌트 kubectl로부터 리소스를 조작하라는 지시를 받음 |
| etcd                    | 고가용성을 갖춘 분산 키-값 스토어. 쿠버네티스 클러스터의 백킹 스토어로 쓰임 |
| kube-scheduler          | 노드를 모니터링하고 컨테이너를 배치할 적절한 노드를 선택     |
| Kube-controller-manager | 리소스를 제어하는 컨트롤러를 실행                            |



## 네임 스페이스

쿠버네티스는 **클러스터 안에 가상 클러스터**를 만들 수 있음

### 네임스페이스(namespace) 개념

- **클러스터안의 가상 클러스터**.

- 개발팀이 일정 규모 이상일때 유리. 즉, 개발자마다 자신의 네임스페이스를 두면, 메인 네임스페이스가 어질러지는 것을 방지할 수 있음 (권한 설정도 가능하여 더욱 편리)

- 클러스터를 처음 구축하면 `default`, `docker`, `kube-public`, `kube-system` 의 네임스페이스 4개가 만들어짐

- 아래 명렁어를 통해 현재 클러스터 안에 존재하는 네임스페이스 목록 확인 가능

  ```shell
  kubectl get namespace
  ```



## 파드

### 파드(pod) 개념

- **컨테이너가 모인 집합체 단위**로, 적어도 하나 이상의 컨테이너로 이루어짐
- 결합이 강한 컨테이너를 파드로 묶어 일괄 배포하고, 컨테이너가 하나인 경우에도 파드로 배포
- 같은 파드를 여러 노드에 배치할 수 있고, 한 노드에 여러개 배치 가능. 단, 파드하나가 여러 노드에 걸쳐 배포할 수는 없음
- 즉, **컨테이너 집합 중 가장 작은 단위**
- 따라서, 함께 배포해야 정합성을 유지할 수 있는 컨테이너들도 같은 파드로 묶어두는 전략이 유용

### 파드 생성 및 배포하기

1. 아래와 같이 **yaml 파일을 만듦**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: simple-echo
spec:
  containers:
  - name: nginx 
    image: gihyodocker/nginx:latest 
    env: 
    - name: BACKEND_HOST
      value: localhost:8080
    ports:
    - containerPort: 80 
  - name: echo
    image: gihyodocker/echo:latest
    ports:
    - containerPort: 8080
```

**각 속성 의미**

- `kind` :  쿠버네티스 리소스의 유형 지정
- `metadata` : 리소스에 부여되는 메타데이터. 즉, `metadata.name` 값이 이 리소스의 이름.
- `spec` : 리소스를 정의하는 속성, 파드의 경우 파드를 구성하는 컨테이너를 `containers` 아래에 정의
  - **`containers` 에 속하는 속성**
    - `name` : 컨테이너 이름
    - `image` : 레지스트리+이미지명
    - `ports` : 컨테이너를 노출시킬 포트 지정 (Dockerfile에서 EXPOSE를 정의한 경우 필요 X)
    - `env` : 환경변수 열거 기능

2. 매니페스트 파일인 yaml 파일의 내용 그대로 반영하여 **파드를 쿠버네티스 클러스터에 배포**하기 위해, 아래 명령어 실행

   ```sh
   kubectl apply -f <yaml 파일 명>
   ```

   - -f 옵션 : 매니페스트 파일 경로 지정

   - 이 명령어를 통해 pod가 생성 및 배포되어 동작하지만 접근 할 수 있는 것은 X → 파드에 접근하기 위해서는 **서비스** 사용

   - 또한 파드에 할당된 가상 IP 주소는 해당 파드에 속하는 모든 컨테이너가 공유하므로, 위 예시의 nginx, echo 컨테이너는 같은 ip 주소를 가짐 

     - 예시 

       - nginx 컨테이너 주소 : 127.0.0.1:80

       - echo 컨테이너 주소 : 127.0.0.1:8080

### 파드 다루기

파드를 조작하는 기본 방법을 기록

- 파드의 상태 목록 조회 : `kubectl get` 명령어 사용

  ```
  kubectl get pod
  ```

- (파드 내) 컨테이너 안에 접근 : `kubectl exec` 명령어 사용

  - 예시

    ```
    kubectl exec -it simple-echo sh -c nginx
    ```

    위 예시처럼 파드안의 컨테이너가 여러개인 경우 -c 옵션에 컨테이너 명 지정

- (파드 내) 컨테이너이 표준 출력을 화면에 출력 : `kubectl logs` 명령어 사용

  - 예시

    ```
    $ kubectl logs -f simple-echo -c echo
    2018/01/03 23:32:43 start server
    ```

- 파드 삭제 : `kubectl delete pod` 명령어 사용

  - 예시

    ```
    $ kubectl delete pod simple-echo
    pod "simple-echo" deleted
    ```

- 매니페스트 파일을 이용한 파드 삭제 :  `kubectl delete -f` 명령어 사용

  - 예시

    ```
    kubectl delete -f simple-pod.yaml
    ```

  

## 레플리카세트

파드를 정의한 매니페스트 파일로는 파드를 하나만 실행

하지만 규모가 있는 애플리케이션을 구축하려면, **같은 파드를 여러개 실행해 가용성 확보** 해야함

- 레플리카세트 : 똑같은 정의를 갖는 파드를 여러개 생성하고 관리하기 위한 리소스

```
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: echo 
  labels:
    app: echo 
spec:
  replicas: 3
  selector:
    matchLabels:
      app: echo 
  template: # template 아래는 파드 리소스 정의와 같음
    metadata:
      labels:
        app: echo
    spec:
      containers:
      - name: nginx 
        image: gihyodocker/nginx:latest 
        env: 
        - name: BACKEND_HOST
          value: localhost:8080
        ports:
        - containerPort: 80 
      - name: echo
        image: gihyodocker/echo:latest
        ports:
        - containerPort: 8080
```

- 위 yaml 파일에서 보이는 것과 같이, `replicas` 는 레플리카세트에서 만들 파드의 복제수를 의미

- 삭제된 파드는 복원 X → 웹애플리케이션과 같은 **무상태(stateless) 파드를 사용하기에 좋음**

- 생성한 레플리카세트는 매니페스트 파일을 이용해 삭제 가능

  ```
  kubectl delete -f <매니페스트 파일명>
  ```



## 디플로이먼트

디플로이먼트는 애플리케이션 배포(deploy)의 기본 단위가 되는 리소스

- 레플리카세트와 디플로이먼트

  - 레플리카세트 : 똑같은 파드의 레플리케이션 개수를 관리 및 제어하는 리소스

  - 디플로이먼트 : 레플리카세트를 관리하고 다루기 위한 리소스, 레플리카세트보다 상위에 해당하는 리소스

    디플로이먼트는 레플리카세트의 리비전 관리 가능

### 레플리카세트의 생애주기

- 디플로이먼트의 레플리카세트 관리 역활
  - 지정된 갯수만큼 파드 확보
  - 파드를 새로운 버전으로 교체
  - 이전 버전으로 롤백
- 디플로이먼트를 수정하면 레플리카세트가 새로 생성되어 기존 레플리카세트와 교체됨
  - 컨테이너 정의 수정시 교체 O
  - 파드 개수 수정시 교체 X

### 롤백 실행하기

- 디플로이먼트는 리비전 번호 기록되므로, **특정 리비전의 내용 확인 가능** → 아래 명령어를 통해 특정 리비전 내용(Pod Template) 확인 가능

  ```
  kubectl rollout history deployment <디플로이먼트이름> --revision=1
  ```

- `undo` 실행 시, 디플로이먼트가 바로 직전 리비전 롤백

  ```
  $ kubectl rollout undo deployment <디플로이먼트이름>
  deployment <디플로이먼트이름> rolled back
  ```

- **롤백 기능으로 최신 디플로이먼트에 이상이 있을시, 곧바로 이전 버전으로 돌아갈 수 있음**

### 디플로이먼트 삭제

- 매니페스트 파일을 이용해 삭제

  ```
  kubectl delete -f <해당 매니페스트 파일명>
  ```

  

## 참고자료

- 도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문