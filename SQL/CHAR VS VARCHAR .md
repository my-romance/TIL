# CHAR VS VARCHAR 

[TOC]

## CHAR

- **고정** 길이
- **남는 공간은 공백으로 채움**
  - CHAR(10)인데 'test'라는 4자짜리 문자열을 삽입하면 남는 공간은 6개의 공백으로 채움
  - 따라서 무조건 처음 선언된 10byte가 소요됨
- 값을 받아 올 때 **공백은 자동으로 제거됨**
  - 공백까지 읽고 싶다면 *PAD_CHAR_TO_FULL_LENGTH* 모드를 활성화하면 공백까지 다 읽어옴
- 데이터가 선언된 길이보다 작다면 남는 공간은 공백으로 채우므로 공간의 **낭비 발생**
- 따라서 고정길이에 해당하는 데이터를 CHAR로 선언하면 효율적



## VARCHAR

- **가변** 길이
- 실질적인 데이터와 함께 **길이 정보**도 저장
  - 데이터를 삽입하면 실질적인 문자열 외에 삽입된 문자열의 길이를 저장
  - 255글자 이하를 나타내는 길이정보는 1바이트, 그 이상은 2바이트의 추가 공간을 필요로 함
  - VARCHAR(10)에 'test'라는 4자짜리 문자열을 삽입하면 4byte + 1byte(길이를 저장하기 위한 공간), 즉 5byte가 소모됨
- 따라서, 남는 공간은 공백으로 채우지 X
  - 하지만 **공백에 대한 처리는 버전**에 따라 다르다.
  - MySQL 5.0.3 **이후**부터는 표준 SQL과의 호환성을 위해 뒤따르는 **공백들을 제거하지 않고 보관**하며 **읽어들일 때도 보존**해준다.
  - MySQL 5.0.3 **이전**에는 저장될 때에 뒤따르는 **공백들은 제거**되었고 이는 값을 읽어들일 때에도 **제거된 채로 읽힘**을 의미한다.
  - MySQL 5.0.3 이전에 뒤따르는 공백들을 유지하기 위해서는 BLOB나 TEXT 형을 선택해야 했다.
- 명시한 데이터 공간보다 큰 데이터를 저장하기 위해서 **새로운 저장 영역에 새로 할당**해야하므로 데이터 파편화 발생



## CHAR VS VARCHAR

### 저장 공간

- VARCHAR은 가변 길이를 저장하므로, 실제로 필요한 저장 공간은 실제 데이터 크기
- 다양한 길이의 데이터를 저장할때는 VARCHAR을 사용하는 것이 효율적

### 비교 방법

- CHAR(8)이고 'AA'가 저장되어 있다면, 'AA'뒤에 공백 6자리를 붙어있는 것이기에
  -  'AA' = 'AA  '은 실제로 'AA      ' = 'AA      '가 되어 같다는 결과가 나온다.
- VARCHAR(8)에서는 공백도 하나의 문자로 취급하므로 끝에 공백이 들어가면 다른 문자로 판단
  -  'AA' != 'AA '로 공백이 있어 서로 다른 문자로 판단

- 사번, 주민등록번호처럼 길이와 형식이 같은 데이터는 CHAR을 사용하는 것이 좋음

### 속도측면

- VARCHAR형의 경우 일일이 그 길이를 계산하여야 다음 ROW를 얻을 수 있는 반면
- CHAR형의 경우는 항상 고정된 ROW 사이즈를 가지고 있으므로 훨씬 빠르다.

### strict SQL Mode

- strict SQL Mode 활성화 X
  - 열의 최대 길이를 초과하여 값을 저장하도록 하면, 값을 최대 길이까지 잘라서 저장하고 경고를 발생시킴
- strict SQL Mode 활성화 O
  - 열의 최대 길이를 초과하면, 에러를 발생시키고 값을 추가하지 못함. 에러를 발생시킴
- 공백이 해당 열의 길이를 초과하는 경우
  - VARCHAR : strict SQL Mode에 관계없이 잘린 후 저장되며 경고를 발생시킴
  - CHAR : strict SQL Mode에 관계없이 잘린 후 저장되고, 경고는 발생 X





## 참고자료

- https://goodgid.github.io/JS-char-vs-varchar/